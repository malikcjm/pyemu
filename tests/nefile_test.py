#!/usr/bin/env python2
from __future__ import print_function
import sys

sys.path.append(r'..')
sys.path.append(r'../lib')

import nefile
from capstone import *
from capstone.x86 import *

import sys
_python3 = sys.version_info.major == 3


def to_hex(s):
    if _python3:
        return " ".join("0x{0:02x}".format(c) for c in s)  # <-- Python 3 is OK
    else:
        return " ".join("0x{0:02x}".format(ord(c)) for c in s)

def to_hex2(s):
    if _python3:
        r = "".join("{0:02x}".format(c) for c in s)  # <-- Python 3 is OK
    else:
        r = "".join("{0:02x}".format(ord(c)) for c in s)
    while r[0] == '0': r = r[1:]
    return r

def to_x(s):
    from struct import pack
    if not s: return '0'
    x = pack(">q", s)
    while x[0] in ('\0', 0): x = x[1:]
    return to_hex2(x)

def to_x_32(s):
    from struct import pack
    if not s: return '0'
    x = pack(">i", s)
    while x[0] in ('\0', 0): x = x[1:]
    return to_hex2(x)

def print_insn_detail(mode, insn):
    def print_string_hex(comment, str):
        print(comment, end=' '),
        for c in str:
            print("0x%02x " % c, end=''),
        print()

    # print address, mnemonic and operands
    print("0x%x:\t%s\t%s" % (insn.address, insn.mnemonic, insn.op_str))

    # "data" instruction generated by SKIPDATA option has no detail
    if insn.id == 0:
        return

    # print instruction prefix
    print_string_hex("\tPrefix:", insn.prefix)

    # print instruction's opcode
    print_string_hex("\tOpcode:", insn.opcode)

    # print operand's REX prefix (non-zero value is relavant for x86_64 instructions)
    print("\trex: 0x%x" % (insn.rex))

    # print operand's address size
    print("\taddr_size: %u" % (insn.addr_size))

    # print modRM byte
    print("\tmodrm: 0x%x" % (insn.modrm))

    # print displacement value
    print("\tdisp: 0x%s" % to_x_32(insn.disp))

    # SIB is not available in 16-bit mode
    if (mode & CS_MODE_16 == 0):
        # print SIB byte
        print("\tsib: 0x%x" % (insn.sib))
        if (insn.sib):
            if insn.sib_base != 0:
                print("\t\tsib_base: %s" % (insn.reg_name(insn.sib_base)))
            if insn.sib_index != 0:
                print("\t\tsib_index: %s" % (insn.reg_name(insn.sib_index)))
            if insn.sib_scale != 0:
                print("\t\tsib_scale: %d" % (insn.sib_scale))

    count = insn.op_count(X86_OP_IMM)
    if count > 0:
        print("\timm_count: %u" % count)
        for i in range(count):
            op = insn.op_find(X86_OP_IMM, i + 1)
            print("\t\timms[%u]: 0x%s" % (i + 1, to_x(op.imm)))

    if len(insn.operands) > 0:
        print("\top_count: %u" % len(insn.operands))
        c = -1
        for i in insn.operands:
            c += 1
            if i.type == X86_OP_REG:
                print("\t\toperands[%u].type: REG = %s" % (c, insn.reg_name(i.reg)))
            if i.type == X86_OP_IMM:
                print("\t\toperands[%u].type: IMM = 0x%s" % (c, to_x(i.imm)))
            if i.type == X86_OP_FP:
                print("\t\toperands[%u].type: FP = %f" % (c, i.fp))
            if i.type == X86_OP_MEM:
                print("\t\toperands[%u].type: MEM" % c)
                if i.mem.segment != 0:
                    print("\t\t\toperands[%u].mem.segment: REG = %s" % (c, insn.reg_name(i.mem.segment)))
                if i.mem.base != 0:
                    print("\t\t\toperands[%u].mem.base: REG = %s" % (c, insn.reg_name(i.mem.base)))
                if i.mem.index != 0:
                    print("\t\t\toperands[%u].mem.index: REG = %s" % (c, insn.reg_name(i.mem.index)))
                if i.mem.scale != 1:
                    print("\t\t\toperands[%u].mem.scale: %u" % (c, i.mem.scale))
                if i.mem.disp != 0:
                    print("\t\t\toperands[%u].mem.disp: 0x%s" % (c, to_x(i.mem.disp)))

            # AVX broadcast type
            if i.avx_bcast != X86_AVX_BCAST_INVALID:
                print("\t\toperands[%u].avx_bcast: %u" % (c, i.avx_bcast))

            # AVX zero opmask {z}
            if i.avx_zero_opmask:
                print("\t\toperands[%u].avx_zero_opmask: TRUE" % (c))

            print("\t\toperands[%u].size: %u" % (c, i.size))


ne = nefile.NE(sys.argv[1])
print(len(ne.segmentTable), "Start %4X:%4X" % (ne.NE_HEADER.InitialCS, ne.NE_HEADER.InitialIP))
code = ne.get_segment_data(ne.NE_HEADER.InitialCS - 1 )
code_seg03 = ne.get_segment_data(2)

print("cseg02 seg flags %04x" % ne.segmentTable[1].Flags)

print("cseg02 reloc data count %d" % len(ne.relocData[1]))

reloc_code_seg = ne.relocData[1]


reloc_address_type = {
    0x00 : "Low byte at specified offset",
    0x02 : "16-bit selector",
    0x03 : "32-bit pointer",
    0x05 : "16-bit offset",
    11   : "48-bit pointer",
    13   : "32-bit offset"
}

class RelocTypeEnum:
    INTERNAL_REFERENCE = 0
    IMPORTED_ORDINAL = 1

reloc_type = {
    0 : "Internal reference",
    1 : "Imported ordinal",
    2 : "Imported name",
    3 : "OSFIXUP"
}

for reloc in reloc_code_seg:
    print("Offset %04x" % reloc.Offset)
    print("AddressType %d %s" % (reloc.AddressType, reloc_address_type[reloc.AddressType]))
    print("RelocType   %d %s" % (reloc.RelocType, reloc_type[reloc.RelocType]))
    if reloc.RelocType == RelocTypeEnum.IMPORTED_ORDINAL:
        print("Module name %s, ordinal % 4d" % (ne.imported_name_table[reloc.Target1-1], reloc.Target2))
    elif reloc.RelocType == RelocTypeEnum.INTERNAL_REFERENCE:
        print("Internal reference")
    else:
        print("FUCK !!!!!")


startIP = ne.NE_HEADER.InitialIP
startIP = 0x46
mode = CS_MODE_16

CS_REG=ne.NE_HEADER.InitialCS
md = Cs(CS_ARCH_X86, mode)
md.detail = True

#print code_seg03[startIP:startIP+13].encode('hex')

#for i in md.disasm(code_seg03[startIP:0xa6], startIP):
#    print "%x:0x%x:\t%s\t%s" % (CS_REG, i.address, i.mnemonic, i.op_str)
#    print_insn_detail(mode, i)

#instr = pydasm.get_instruction(code[startIP:startIP+13], pydasm.MODE_16)
#print pydasm.get_instruction_string(instr, pydasm.FORMAT_INTEL, 0)
